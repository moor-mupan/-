1.标准盒模型与变异盒模型(IE)
	--标准 - 宽高不包含 padding 和 border
	-- IE  - 宽高包含 padding 和 border
	
2.<meta />标签
	-- 属性 name , http-equiv
	-- name 对应属性值为 content
	<meta name='参数' content='具体的描述' />
	-- name 属性的参数
		-- 1.keywords -- (用于告诉搜索引擎)网页关键字
		-- 2.description -- ...网页描述
		-- 3.viewport -- 移动端窗口
		-- 4.robots(定义搜索引擎爬虫的索引方式) -- content 值(all,none,noindex,nofollow,index,follow)
		-- 5.author -- 网页作者
		-- 6.generator -- 网页制作软件
		-- 7.copyright -- 版权
		-- 8.revisit-after -- 搜索引擎爬虫重访时间
		-- 9.renderer -- 双核浏览器渲染方式
	<meta http-equiv="参数" content="具体的描述">
	-- http-equiv 属性的参数
		-- 1.content-Type(设定网页字符集)(推荐使用HTML5的方式)
			<meta http-equiv="content-Type" content="text/html;charset=utf-8">//旧的HTML，不推荐
			<meta charset="utf-8"> //HTML5设定网页字符集的方式，推荐使用UTF-8
		-- 2.X-UA-Compatible(浏览器采取何种版本渲染当前页面)
			<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/> //指定IE和Chrome使用最新版本渲染当前页面
		-- 3.cache-control(指定请求和响应遵循的缓存机制)
			<meta http-equiv="cache-control" content="no-cache">
			content的值：
				-- 1.no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存
				-- 2.no-store: 不允许缓存，每次都要去服务器上，下载完整的响应(安全措施)
				-- 3.public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果
				-- 4.private : 只为单个用户缓存，因此不允许任何中继进行缓存(比如说CDN就不允许缓存private的响应)
				-- 5.maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求,max-age=60表60秒
				-- 6.no-siteapp: 禁止百度自动转码 <meta http-equiv="Cache-Control" content="no-siteapp" />
		-- 4.expires(网页到期时间)过期后网页必须到服务器上重新传输
			<meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" />
		-- 5.refresh(自动刷新并指向某页面)网页将在设定的时间内，自动刷新并调向设定的网址
			<meta http-equiv="refresh" content="2；URL=http://www.lxxyx.win/"> //意思是2秒后跳转向我的博客
		-- 6.Set-Cookie(cookie设定)
			<meta http-equiv="Set-Cookie" content="User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT">

3.img 图片出现底部空白问题 
	-- 出现原因 -- 内联元素是基于父元素的 baseline 对齐的，而父元素是基于 topline 和 bottomline 撑开的 
		  -- 空白区就是 baseline 和 bottomline 之间的间隙
	-- 1.将父元素的行高设置为0 -- lineheight: 0;
	-- 2.浮动
	-- 3.将图片设置为块元素 -- display: block;
	-- 4.设置图片的垂直对齐方式 -- vertical-align: middle;
	
4.<marquee>我是滚动文字</marquee>标签实现文字滚动效果

5.HTML5新属性 -- contenteditable -- 设置文本为可编辑

6.box-shadow -- 实现多重阴影效果(在阴影半径后添加一个阴影距离) 
	-- box-shadow: 0 0 0 2px blue,
				   0 0 0 4px red,
				   0 0 0 6px yellow,
				   0 0 0 8px pink,
				   0 0 0 10px orange;
				   
7.cale()可进行 + - x ÷ 计算 -- 例如: width: calc(100% - (10px + 5px) * 2);

8.实现不断运动的虚线边框效果
	--  div {
			width: 100px;
			height: 100px;
		    border: 1px solid transparent;
		    background: 
				/* linear-gradient(#fff, yellow) padding-box, */
				repeating-linear-gradient(-45deg, black 0, black 2%, white 0, white 4%) 0/400px;
		    animation:ants 12s linear infinite;
		}
	    @keyframes ants {
			to { background-position: 100% }
	    }
		
9.前端性能优化
	-- 1.减少HTTP请求
	-- 2.使用CDN 
		-- 优点：CDN还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和Web流量峰值压力
		-- 缺点：响应时间可能会受到其他网站流量的影响
	-- 3.合理添加 Expires 头 -- expires 起到控制页面缓存时间的作用，合理的配置 expires 可以减少很多服务器的请求
	-- 4.将样式表放在头部，js脚本放在底部
	-- 5.避免 CSS 表达式
	-- 6.使用外部的 JavaScript 和 CSS(内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，
			-- 当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小)
	-- 7.精简代码,合理使用浏览器缓存等等

10.浏览器缓存(从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。)
	-- 1.Service Worker
	-- 2.Memory Cache
	-- 3.Disk Cache
	-- 4.Push Cache
	-- 通常浏览器缓存策略分为两种：强缓存 - 协议缓存 

11.JS 中的常用排序算法
	-- 1.sort(/* 会改变原数组 */) -- arr.sort() / arr.sort(function(a, b){return a - b}) 
	-- 2.冒泡排序
		-- let arr = [2, 3, 5, 1, 1, 4, 9];
		-- for (let i = arr.length - 1; i > 0; i--) { //外层循环控制排序趟数
				for (let j = 0; j < i; j++) { //内层循环控制每一趟排序多少次
					if (arr[j] < arr[j + 1]) {
						let temp = arr[j];
						arr[j] = arr[j + 1];
						arr[j + 1] = temp;
					}
				}
			}
		-- arr --> 9, 5, 4, 3, 2, 1, 1 
	-- 3.二叉树排序
		-- function BinaryTree() {
				let Node = function (key) {
					this.key = key;
					this.left = null;
					this.right = null;
				}
				let root = null;
				let insertNode = function (node, newNode) {
					if (newNode.key < node.key) {
						if (node.left === null) {
							node.left = newNode;
						} else {
							insertNode(node.left, newNode);
						}
					} else {
						if (node.right === null ){
							node.right = newNode;
						} else {
							insertNode(node.right, newNode);
						}
					}
					
				}
				this.insert = function (key) {
					let newNode = new Node(key);
					if (root === null) {
						root = newNode;
					} else {
						insertNode(root, newNode)
					}
				}
				// 中序遍历
				let traverseNode = function (node, callback) {
					if (node !== null) {
						// 访问左子数 -- 
						traverseNode(node.left, callback);
						// 得到当前节点--
						callback(node.key);
						// 访问右子数 -- 
						traverseNode(node.right, callback);
					}
				}
				this.traverse = function (callback) {
					traverseNode(root, callback)
				}
			}
			let binaryTree = new BinaryTree()
			arr.forEach(function(key){
				binaryTree.insert(key)
			})
			let callback = function (key) {
				console.log(key)
			}
			binaryTree.traverse(callback)
12.Vue -- 知识总结
	-- 1.MVC(Controller) --> MVP(Presenter) --> MVVM(viewModel)
	-- 2.组件间的传值
		-- 父 --> 子 -- props 
		-- 子 --> 父	 -- 事件($emit 触发)
		-- 任意组件间 -- Bus 总线 / slot 插槽
	-- 3.Vuex 状态管理
		-- state -- getter -- mutation -- action -- module
	-- 4.v-if(销毁元素-重新创建元素)  v-show(控制display实现显示隐藏)
	
13.正则表达式 (大写字母反义)
	-- \b 单词边界
	-- \d 数字字符
	-- \s 空白字符
	-- \w 匹配包括下划线的任何单词字符
	-- 电子邮箱：
		-- /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/
		-- /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/
	-- 用户名：
		-- /^[a-z0-9_-]{3,16}$/
	-- 密码：
		-- /^[a-z0-9_-]{6,18}$/
	-- URL：
		-- /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

14.