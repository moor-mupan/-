1.标准盒模型与变异盒模型(IE)

	标准 - 宽高不包含 padding 和 border
	IE  - 宽高包含 padding 和 border
	
2.<meta />标签

	 属性 name , http-equiv
	 name 对应属性值为 content
	 <meta name='参数' content='具体的描述' />
	 name 属性的参数
		 1.keywords  (用于告诉搜索引擎)网页关键字
		 2.description  ...网页描述
		 3.viewport  移动端窗口
		 4.robots(定义搜索引擎爬虫的索引方式)  content 值(all,none,noindex,nofollow,index,follow)
		 5.author  网页作者
		 6.generator  网页制作软件
		 7.copyright  版权
		 8.revisit-after  搜索引擎爬虫重访时间
		 9.renderer  双核浏览器渲染方式

	 <meta http-equiv="参数" content="具体的描述">
	 http-equiv 属性的参数
		 1.content-Type(设定网页字符集)(推荐使用HTML5的方式)
			<meta http-equiv="content-Type" content="text/html;charset=utf-8">//旧的HTML，不推荐
			<meta charset="utf-8"> //HTML5设定网页字符集的方式，推荐使用UTF-8
		 2.X-UA-Compatible(浏览器采取何种版本渲染当前页面)
			<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/> //指定IE和Chrome使用最新版本渲染当前页面
		 3.cache-control(指定请求和响应遵循的缓存机制)
			<meta http-equiv="cache-control" content="no-cache">
			content的值：
				 1.no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存
				 2.no-store: 不允许缓存，每次都要去服务器上，下载完整的响应(安全措施)
				 3.public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果
				 4.private : 只为单个用户缓存，因此不允许任何中继进行缓存(比如说CDN就不允许缓存private的响应)
				 5.maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求,max-age=60表60秒
				 6.no-siteapp: 禁止百度自动转码 <meta http-equiv="Cache-Control" content="no-siteapp" />
		 4.expires(网页到期时间)过期后网页必须到服务器上重新传输
			<meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" />
		 5.refresh(自动刷新并指向某页面)网页将在设定的时间内，自动刷新并调向设定的网址
			<meta http-equiv="refresh" content="2；URL=http://www.lxxyx.win/"> //意思是2秒后跳转向我的博客
		 6.Set-Cookie(cookie设定)
			<meta http-equiv="Set-Cookie" content="User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT">

3.img 图片出现底部空白问题 

	 出现原因  内联元素是基于父元素的 baseline 对齐的，而父元素是基于 topline 和 bottomline 撑开的 
		   空白区就是 baseline 和 bottomline 之间的间隙
	 1.将父元素的行高设置为0  lineheight: 0;
	 2.浮动
	 3.将图片设置为块元素  display: block;
	 4.设置图片的垂直对齐方式  vertical-align: middle;
	
4.marquee标签实现文字滚动效果
  	<marquee>marquee标签实现文字滚动效果</marquee>	

5.HTML5新属性  contenteditable  设置文本为可编辑

6.box-shadow  实现多重阴影效果(在阴影半径后添加一个阴影距离)
	 
	 box-shadow: 0 0 0 2px blue,
				   0 0 0 4px red,
				   0 0 0 6px yellow,
				   0 0 0 8px pink,
				   0 0 0 10px orange;			   	
	   
7.cale()可进行 + - x ÷ 计算  例如: width: calc(100% - (10px + 5px) * 2);

8.实现不断运动的虚线边框效果

	  div {
			width: 100px;
			height: 100px;
		    border: 1px solid transparent;
		    background: 
				/* linear-gradient(#fff, yellow) padding-box, */
				repeating-linear-gradient(-45deg, black 0, black 2%, white 0, white 4%) 0/400px;
		    animation:ants 12s linear infinite;
		}
	    @keyframes ants {
			to { background-position: 100% }
	    }
		
9.前端性能优化 

      （1）减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

      （2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

      （3）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

      （4）当需要设置的样式很多时设置className而不是直接操作style。

      （5）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

      （6）避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

      （7）图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

      （8）避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
		    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。
			向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，
			能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，
			本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。
			减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），
			减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。  		   	


10.浏览器缓存(从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。)

	 1.Service Worker
	 2.Memory Cache
	 3.Disk Cache
	 4.Push Cache
	 通常浏览器缓存策略分为两种：强缓存 - 协议缓存 

11.JS 中的常用排序算法

	 1.sort(/* 会改变原数组 */)  arr.sort() / arr.sort(function(a, b){return a - b}) 
	 2.冒泡排序
		 let arr = [2, 3, 5, 1, 1, 4, 9];
		 for (let i = arr.length - 1; i > 0; i) { //外层循环控制排序趟数
				for (let j = 0; j < i; j++) { //内层循环控制每一趟排序多少次
					if (arr[j] < arr[j + 1]) {
						let temp = arr[j];
						arr[j] = arr[j + 1];
						arr[j + 1] = temp;
					}
				}
			}
		 arr > 9, 5, 4, 3, 2, 1, 1 
	 3.二叉树排序 
		 function BinaryTree() {
			let Node = function (key) {
				this.key = key;
				this.left = null;
				this.right = null;
			}
			let root = null;
			let insertNode = function (node, newNode) {
				if (newNode.key < node.key) {
					if (node.left === null) {
						node.left = newNode;
					} else {
						insertNode(node.left, newNode);
					}
				} else {
					if (node.right === null ){
						node.right = newNode;
					} else {
						insertNode(node.right, newNode);
					}
				}
				
			}
			this.insert = function (key) {
				let newNode = new Node(key);
				if (root === null) {
					root = newNode;
				} else {
					insertNode(root, newNode)
				}
			}
			// 中序遍历
			let traverseNode = function (node, callback) {
				if (node !== null) {
					// 访问左子数  
					traverseNode(node.left, callback);
					// 得到当前节点
					callback(node.key);
					// 访问右子数  
					traverseNode(node.right, callback);
				}
			}
			this.traverse = function (callback) {
				traverseNode(root, callback)
			}
		}
		let binaryTree = new BinaryTree()
		arr.forEach(function(key){
			binaryTree.insert(key)
		})
		let callback = function (key) {
			console.log(key)
		}
		binaryTree.traverse(callback)
12.Vue 知识总结

	 1.MVC(Controller) > MVP(Presenter) > MVVM(viewModel)
	 2.组件间的传值
		 父 > 子  props 
		 子 > 父	  事件($emit 触发)
		 任意组件间  Bus 总线 / slot 插槽
	 3.Vuex 状态管理
		 state  getter  mutation  action  module
	 4.v-if(销毁元素-重新创建元素)  v-show(控制display实现显示隐藏)
	
13.正则表达式 (大写字母反义)

	 \b 单词边界
	 \d 数字字符
	 \s 空白字符
	 \w 匹配包括下划线的任何单词字符
	 电子邮箱：
		 /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/
		 /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/
	 用户名：
		 /^[a-z0-9_-]{3,16}$/
	 密码：
		 /^[a-z0-9_-]{6,18}$/
	 URL：
		 /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

14.浏览器内核

	1.IE -- Trident [traɪdnt]
	2.火狐 -- Gecko [gekəʊ] 
	3.Chrome -- webkit
	4.Opera -- 原核 Presto [prestəʊ]  --  现核 Blink [blɪŋk]

15.页面导入样式时，使用 link 和 @import 有什么区别？
	
	1.link属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；而 @import 是 CSS 提供的，只能用于加载 CSS;
	2.页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载;
	3.@import 是CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题;

16.Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.

17.HTML5 新增了哪些属性？ 移除了哪些元素？ 兼容性问题？
	
	1.HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加
	2.新增
		绘画 canvas
		用于媒介回放的 video 和 audio 元素
		本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 -- sessionStorage 的数据在浏览器关闭后自动删除
		语意化更好的内容元素，比如 article、footer、header、nav、section
		表单控件，calendar、date、time、email、url、search
		新的技术webworker, websockt, Geolocation
	3.移除
		纯表现的元素：basefont，big，center，font, s，strike，tt，u；
		对可用性产生负面影响的元素：frame，frameset，noframes；
	4.使用最多的是html5shim框架
		<!--[if lt IE 9]>
		<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
		<![endif]-->

18.HTML5 离线存储

	1.localStorage    长期存储数据，浏览器关闭后数据不丢失；
	2.sessionStorage  数据在浏览器关闭后自动删除。

19.js继承
	
	function Parent （name）{ //父类
		this.name = name
	}
	1.原型链继承 -- 将父类的实例作为子类的原型
		function Child () {}
		Child.prototype = new Parent

	2.构造继承 -- 使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类
		function Child(name){
		  Animal.call(this);
		  this.name = name || 'Tom';
		}
	
	3.实例继承 -- 为父类实例添加新特性，作为子类实例返回
		function Child(name){
		  var instance = new Animal();
		  instance.name = name || 'Tom';
		  return instance;
		}

20.http状态码有那些？分别代表是什么意思？

	1.100-199 用于指定客户端应相应的某些动作。
    2.200-299 用于表示请求成功。
    3.300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。
    4.400-499 用于指出客户端的错误。
		-- 400 -- 语义有误，当前请求无法被服务器理解。
		-- 401 -- 当前请求需要用户验证 
		-- 403 -- 服务器已经理解请求，但是拒绝执行它。
    5.500-599 用于支持服务器错误。 503 – 服务不可用

21.js 闭包
	
	(条件： 函数嵌套 -- 内部函数使用为外部函数变量 -- 调用函数)
	1.js 作用域链 -- 函数创建时创建 -- (寻找变量)自身 -> 父级 -> 更高级
	2.js 内存回收机制
		-- 函数在执行开始的时候，会为其中的变量划分内存空间保存，当函数执行完毕后，回收变量空间。(再次执行重复以上)
		-- 由于在外部函数执行完成后，内部函数仍需使用外部函数变量，因此外部函数变量不会被销毁。
	3.闭包的作用
		-- 封装私有方法
	4.缺点
		-- 函数执行完成后变量仍然存在，内存消耗大，会造成内存泄漏。

22.内存泄漏(变量一直处于“进入环境”的状态，无法被回收)
	
	(常见原因)
	-- 1.定义全局变量
	-- 2.使用闭包
	-- 3.dom清除或删除时，事件未清除导致内存泄漏
	-- 4.子元素存在引起内存泄漏

23.原型链
	
	function Add (num) {
		console.log(num++);
	}
	let add = new Add(8);
	add.__proto__ === Add.prototype

**24.js 基础知识整理** 

1.数组 Array

	-- 对象属性 
		1.constructor (返回对创建此对象的引用)
		2.length（长度）
		3.prototype (向对象添加属性、方法)
	-- 对象方法
		1.concat() 
			连接两个或多个数组并返回结果 
			arrayObject.concat(arrayX,arrayX,......,arrayX)
		2.join() 
			将数组转换为字符串，以指定分隔符分开 
			arrayObject.join(separator/* 分隔符默认为逗号 */)
		3.pop() 
			删除、返回末尾元素
			arrayObject.pop()
		4.push()
			末尾添加，并返回新长度
			arrayObject.push(newelement1,newelement2,....,newelementX)
		5.reverse()
			倒序排列
			arrayObject.reverse()
		6.shift()
			删除、返回第一个元素
			arrayObject.shift()
		7.unshift()
			向数组的开头添加一个或更多元素，并返回新的长度。
			arrayObject.unshift(newelement1,newelement2,....,newelementX)	
		8.slice()
			返回选择的元素
			arrayObject.slice(startIndex,endIndex /* 不包含在内 */)
		9.sort()
			数组排序并返回新数组
			arrayObject.sort(sortby /* 可选,规定排序顺序,必须是函数. */ )
			例如： function init（a, b）{
					/* 顺序排列 */  
					return a - b
				  }
				  let arr = [1,5,2,3,1]
				  arr.sort(init)
		10.splice() 
			删除并插入（该方法会改变原始数组。）
			arrayObject.splice(index /* 下标 */,howmany /* 数量 */,item1,.....,itemX)
		11.toSring()
			把数组转换为字符串，并返回结果。
			arrayObject.toString()
		12.toLocaleString()
			把数组转换为本地字符串。
			arrayObject.toLocaleString()
		(两者区别)
			  1.let a = 1234
				a.toString()			"1234"
				a.toLocaleString()  	"1,234"
			  2.let date = new Date()
				date => Wed Feb 15 2017 11:21:31 GMT+0800 (CST)
				date.toLocaleString() => "2017/2/15 上午11:21:31"
				date.toString() => "Wed Feb 15 2017 11:21:31 GMT+0800 (CST)"	
		13.valueOf()
			返回数组对象的原始值
			arrayObject.valueOf()
2.String 字符串
	
	-- 对象常用方法
		1.charAt(/*index*/)
			返回在指定位置的字符。
		2.charCodeAt(/*index*/)
			返回在指定的位置的字符的 Unicode 编码。
		3.concat(/*stringX,stringX,...,stringX*/)
			连接字符串。
		4.fromCharCode(/*numX,numX,...,numX*/)
			将字符编码转换为字符串
		5.indexOf(/*searchvalue,fromindex*/)
			方法可返回某个指定的字符串值在字符串中首次出现的位置。
		6.lastIndexOf(/*searchvalue,fromindex*/)
			从后向前检索字符串
		7.match(/*regexp*/)
			检索指定的值，或找到一个或多个正则表达式的匹配.
		8.replace(/*regexp/substr,replacement*/)
			匹配并替换
		9.search(/*regexp*/)
			检索与正则表达式相匹配的值。
		10.slice(/*start,end*/)
			提取字符串的某个部分，并以新的字符串返回被提取的部分。
		11.split(/*separator,howmany*/)
			将字符串分割为数组
		12.toLowerCase()	
			把字符串转换为小写。
		13.toUpperCase()
			把字符串转换为大写。
			
3.函数
	
	eval(/*string*/) -  函数可计算某个字符串，并执行其中的的 JavaScript 代码。
	编码 - escape(string)  - 解码 - unescape(string)
	decodeURI()	解码某个编码的 URI。
	decodeURIComponent()	解码一个编码的 URI 组件。
	encodeURI()	把字符串编码为 URI。
	encodeURIComponent()	把字符串编码为 URI 组件
	